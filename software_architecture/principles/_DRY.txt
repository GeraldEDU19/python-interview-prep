=== DRY PRINCIPLE ===

DEFINITION:
DRY stands for "Don't Repeat Yourself" - a principle that states every piece of
knowledge must have a single, unambiguous, authoritative representation within
a system. The goal is to reduce repetition of software patterns, replacing them
with abstractions or using data normalization to avoid redundancy.

Think of DRY like a recipe book:
- Write each recipe once in the cookbook (single source of truth)
- Reference the recipe when needed (reuse)
- Update recipe in one place affects all uses (maintainability)
- Don't write the same recipe in multiple places (avoid duplication)

=== CORE CONCEPTS ===

KNOWLEDGE REPRESENTATION:
- Business logic should exist in one place
- Configuration should be centralized
- Database schemas should be normalized
- Code patterns should be abstracted

TYPES OF DUPLICATION:
1. **Code Duplication**: Same logic written multiple times
2. **Data Duplication**: Same information stored in multiple places
3. **Configuration Duplication**: Same settings in multiple files

=== CODE DUPLICATION EXAMPLES ===

BAD EXAMPLE (Violates DRY):
```python
def calculate_employee_bonus(employee):
    if employee.department == "Sales":
        base_salary = employee.salary
        bonus = base_salary * 0.15
        tax = bonus * 0.3  # Repeated tax calculation
        return bonus - tax
    elif employee.department == "Marketing":
        base_salary = employee.salary
        bonus = base_salary * 0.12
        tax = bonus * 0.3  # Repeated tax calculation
        return bonus - tax
```

GOOD EXAMPLE (Follows DRY):
```python
def calculate_tax(amount, tax_rate=0.3):
    """Single source of truth for tax calculation"""
    return amount * tax_rate

def calculate_bonus(base_amount, bonus_rate):
    """Centralized bonus calculation logic"""
    bonus = base_amount * bonus_rate
    tax = calculate_tax(bonus)
    return bonus - tax

def calculate_employee_bonus(employee):
    """Employee bonus with department-specific rates"""
    bonus_rates = {
        "Sales": 0.15,
        "Marketing": 0.12,
        "Engineering": 0.18
    }
    
    rate = bonus_rates.get(employee.department, 0.10)
    return calculate_bonus(employee.salary, rate)
```

=== CONFIGURATION DUPLICATION ===

BAD EXAMPLE (Repeated Configuration):
```python
# File: user_service.py
DATABASE_URL = "postgresql://user:pass@localhost:5432/myapp"
MAX_CONNECTIONS = 100

# File: order_service.py  
DATABASE_URL = "postgresql://user:pass@localhost:5432/myapp"  # Repeated
MAX_CONNECTIONS = 100  # Repeated
```

GOOD EXAMPLE (Centralized Configuration):
```python
# File: config.py
class Config:
    DATABASE_URL = "postgresql://user:pass@localhost:5432/myapp"
    MAX_CONNECTIONS = 100

# File: user_service.py
from config import Config

def connect_to_database():
    return create_connection(Config.DATABASE_URL)
```

=== DATA DUPLICATION ===

BAD EXAMPLE (Denormalized Data):
```sql
CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_name VARCHAR(100),    -- Repeated in every order
    customer_email VARCHAR(100),   -- Repeated in every order
    order_total DECIMAL(10,2)
);
```

GOOD EXAMPLE (Normalized Data):
```sql
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_id INT REFERENCES customers(id),  -- Single reference
    order_total DECIMAL(10,2)
);
```

=== WHEN DRY HELPS ===

BENEFITS:
✓ Change logic in one place, effect everywhere
✓ Reduced chance of inconsistencies
✓ Easier bug fixes (fix once, fixed everywhere)
✓ Cleaner, more readable code
✓ Faster development (reuse existing code)

=== WHEN DRY CAN HURT ===

OVER-ABSTRACTION:
```python
# BAD: Over-abstracting simple operations
def add_numbers(a, b):
    return a + b

def calculate_order_total(item_price, tax):
    return add_numbers(item_price, tax)  # Unnecessary abstraction
```

WRONG ABSTRACTIONS:
```python
# BAD: Forcing different concepts into same abstraction
def process_item(item, action_type):
    if action_type == "email":
        send_email(item.recipient, item.subject, item.body)
    elif action_type == "sms":
        send_sms(item.phone, item.message)
    # These are different concepts forced together
```

=== GOOD ABSTRACTIONS ===

EXTRACT COMMON PATTERNS:
```python
def validate_required_fields(data, required_fields):
    """Reusable validation logic"""
    missing_fields = [field for field in required_fields 
                     if not data.get(field)]
    if missing_fields:
        raise ValidationError(f"Missing required fields: {missing_fields}")

def validate_user_data(user_data):
    validate_required_fields(user_data, ['name', 'email'])

def validate_order_data(order_data):
    validate_required_fields(order_data, ['customer_id', 'items'])
```

=== BEST PRACTICES ===

IDENTIFY TRUE DUPLICATION:
✓ Same business logic repeated
✓ Same data transformation patterns
✓ Common validation rules
✓ Repeated configuration values

CREATE MEANINGFUL ABSTRACTIONS:
✓ Abstract when you have 3+ similar implementations
✓ Ensure abstraction makes code clearer, not more complex
✓ Name abstractions based on what they do
✓ Keep abstractions focused and single-purpose

AVOID PREMATURE ABSTRACTION:
✓ Wait until duplication actually exists
✓ Don't abstract based on speculation
✓ Prefer simple duplication over complex abstraction initially
✓ Refactor to DRY when patterns become clear

=== PRACTICAL EXAMPLE ===

BEFORE (Violates DRY):
```python
def send_welcome_email(user):
    smtp_server = "smtp.company.com"
    smtp_port = 587
    send_email(user.email, "Welcome!", f"Hi {user.name}!", smtp_server, smtp_port)

def send_reset_email(user):
    smtp_server = "smtp.company.com"  # Repeated
    smtp_port = 587  # Repeated
    send_email(user.email, "Reset", f"Hi {user.name}!", smtp_server, smtp_port)
```

AFTER (Follows DRY):
```python
class EmailService:
    def __init__(self):
        self.smtp_server = "smtp.company.com"
        self.smtp_port = 587
    
    def send_user_email(self, user, subject, body):
        send_email(user.email, subject, body, self.smtp_server, self.smtp_port)

email_service = EmailService()

def send_welcome_email(user):
    email_service.send_user_email(user, "Welcome!", f"Hi {user.name}!")

def send_reset_email(user):
    email_service.send_user_email(user, "Reset", f"Hi {user.name}!")
```

=== CONCLUSION ===

**DO APPLY DRY FOR:**
✓ Business logic that appears in multiple places
✓ Configuration repeated across files
✓ Data stored redundantly
✓ Common patterns and utilities

**DON'T APPLY DRY FOR:**
❌ Coincidentally similar code serving different purposes
❌ Simple operations that don't benefit from abstraction
❌ Code that might evolve in different directions

**KEY PRINCIPLES:**
- Every piece of knowledge should have a single source of truth
- Abstract when duplication is meaningful and stable
- Prefer clarity over premature optimization
- Refactor to DRY when patterns emerge naturally

The goal of DRY is maintainability and consistency, not just reducing lines of code.