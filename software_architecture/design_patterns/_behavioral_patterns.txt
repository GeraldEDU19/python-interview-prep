=== BEHAVIORAL DESIGN PATTERNS ===

DEFINITION:
Behavioral patterns focus on communication between objects and the assignment
of responsibilities. They help define how objects interact and distribute work.

PATTERNS COVERED:
1. **Observer** - One-to-many notifications when object state changes
2. **Strategy** - Interchangeable algorithms/behaviors at runtime  
3. **Command** - Encapsulate operations as objects for undo/redo/queuing

=== 1. OBSERVER PATTERN ===

PURPOSE:
Defines a one-to-many dependency between objects so that when one object changes
state, all dependents are notified automatically.

USE CASES: Event handling, notifications, pub-sub systems

IMPLEMENTATION:
```python
from abc import ABC, abstractmethod

# Observer interface
class Observer(ABC):
    @abstractmethod
    def update(self, message):
        pass

# Subject (Observable)
class Subject:
    def __init__(self):
        self._observers = []
    
    def attach(self, observer):
        self._observers.append(observer)
    
    def notify(self, message):
        for observer in self._observers:
            observer.update(message)

# Concrete observers
class EmailNotifier(Observer):
    def update(self, message):
        print(f"Email: {message}")

# Concrete subject
class NewsAgency(Subject):
    def set_news(self, news):
        self.notify(f"Breaking News: {news}")

# Usage
news = NewsAgency()
email = EmailNotifier()
news.attach(email)
news.set_news("Python 4.0 Released!")  # Email: Breaking News: Python 4.0 Released!
```

=== 2. STRATEGY PATTERN ===

PURPOSE:
Defines a family of algorithms, encapsulates each one, and makes them
interchangeable. Strategy lets the algorithm vary independently from clients.

USE CASES: Payment processing, sorting algorithms, validation

IMPLEMENTATION:
```python
from abc import ABC, abstractmethod

# Strategy interface
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

# Concrete strategies
class CreditCardPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} via Credit Card"

class PayPalPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} via PayPal"

# Context class
class ShoppingCart:
    def __init__(self):
        self.total = 0
        self.payment_strategy = None
    
    def set_payment_strategy(self, strategy):
        self.payment_strategy = strategy
    
    def checkout(self, amount):
        return self.payment_strategy.pay(amount)

# Usage
cart = ShoppingCart()
cart.set_payment_strategy(CreditCardPayment())
print(cart.checkout(100))  # Paid $100 via Credit Card

cart.set_payment_strategy(PayPalPayment())
print(cart.checkout(100))  # Paid $100 via PayPal
```

=== 3. COMMAND PATTERN ===

PURPOSE:
Encapsulates a request as an object, allowing you to parameterize clients with
different requests, queue operations, and support undo operations.

USE CASES: GUI buttons, undo/redo, job queues, logging

IMPLEMENTATION:
```python
from abc import ABC, abstractmethod

# Command interface
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

# Receiver classes
class Light:
    def __init__(self, location):
        self.location = location
        self.is_on = False
    
    def turn_on(self):
        self.is_on = True
        print(f"{self.location} light is ON")
    
    def turn_off(self):
        self.is_on = False
        print(f"{self.location} light is OFF")

# Concrete commands
class LightOnCommand(Command):
    def __init__(self, light):
        self.light = light
    
    def execute(self):
        self.light.turn_on()
    
    def undo(self):
        self.light.turn_off()

class LightOffCommand(Command):
    def __init__(self, light):
        self.light = light
    
    def execute(self):
        self.light.turn_off()
    
    def undo(self):
        self.light.turn_on()

# Invoker
class RemoteControl:
    def __init__(self):
        self.last_command = None
    
    def press_button(self, command):
        command.execute()
        self.last_command = command
    
    def press_undo(self):
        if self.last_command:
            self.last_command.undo()

# Usage
light = Light("Living Room")
light_on = LightOnCommand(light)
remote = RemoteControl()

remote.press_button(light_on)  # Living Room light is ON
remote.press_undo()            # Living Room light is OFF
```

=== WHEN TO USE EACH PATTERN ===

**OBSERVER:**
✓ When changes to one object require updating multiple objects
✓ For event-driven architectures
❌ Can cause performance issues with many observers

**STRATEGY:**
✓ When you have multiple ways to perform a task
✓ When you want to switch algorithms at runtime
❌ Clients must know about different strategies

**COMMAND:**
✓ For undo/redo functionality
✓ To log, queue, or schedule operations
❌ Can create many small classes

=== CONCLUSION ===

Behavioral patterns define how objects communicate:

**OBSERVER** enables one-to-many notifications
**STRATEGY** makes algorithms interchangeable  
**COMMAND** encapsulates operations as objects

Choose based on your communication needs:
- Observer for event-driven updates
- Strategy for algorithm variations
- Command for operation encapsulation and undo functionality

These patterns promote loose coupling and flexible object interactions