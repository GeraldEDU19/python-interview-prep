=== REST API CONCEPTS AND BEST PRACTICES ===

DEFINITION:
REST (Representational State Transfer) is an architectural style for designing web services
that uses standard HTTP methods to perform operations on resources. A RESTful API treats
data as resources that can be accessed and manipulated using a uniform interface.

Think of REST like a restaurant menu system:
- Resources are dishes (users, orders, products)
- HTTP methods are actions (view menu, order food, cancel order)
- URLs are addresses (table numbers, specific dishes)
- Status codes are responses (order confirmed, dish not available)

=== CORE PRINCIPLES OF REST ===

1. STATELESS:
   - Each request must contain all information needed to process it
   - Server doesn't store client context between requests
   - Makes scaling easier and improves reliability

2. CLIENT-SERVER ARCHITECTURE:
   - Clear separation between client and server
   - Client handles user interface and user state
   - Server handles data storage and business logic

3. CACHEABLE:
   - Responses should indicate if they can be cached
   - Improves performance and reduces server load
   - Use appropriate cache headers

4. UNIFORM INTERFACE:
   - Consistent way to interact with resources
   - Uses standard HTTP methods and status codes
   - Self-descriptive messages

5. LAYERED SYSTEM:
   - Architecture can have multiple layers
   - Client doesn't need to know if connected to end server
   - Allows for load balancers, proxies, gateways

6. CODE ON DEMAND (Optional):
   - Server can send executable code to client
   - Rarely used in modern REST APIs

=== HTTP METHODS (VERBS) ===

GET - Retrieve Resource:
- Purpose: Fetch data without modifying server state
- Safe: Yes (no side effects)
- Idempotent: Yes (same result with multiple calls)
- Example: GET /api/users/123

POST - Create Resource:
- Purpose: Create new resources or submit data
- Safe: No (has side effects)
- Idempotent: No (multiple calls create multiple resources)
- Example: POST /api/users (with user data in body)

PUT - Update/Replace Resource:
- Purpose: Update entire resource or create if doesn't exist
- Safe: No (modifies data)
- Idempotent: Yes (same result with multiple calls)
- Example: PUT /api/users/123 (with complete user data)

PATCH - Partial Update:
- Purpose: Partially update a resource
- Safe: No (modifies data)
- Idempotent: Yes (usually, depends on implementation)
- Example: PATCH /api/users/123 (with only changed fields)

DELETE - Remove Resource:
- Purpose: Delete a resource
- Safe: No (modifies data)
- Idempotent: Yes (deleting same resource multiple times = same result)
- Example: DELETE /api/users/123

HEAD - Get Headers Only:
- Purpose: Get response headers without body
- Safe: Yes
- Idempotent: Yes
- Example: HEAD /api/users/123

OPTIONS - Get Allowed Methods:
- Purpose: Discover allowed methods for a resource
- Safe: Yes
- Idempotent: Yes
- Example: OPTIONS /api/users

=== HTTP STATUS CODES ===

SUCCESS (2xx):
200 OK - Request successful, response has body
201 Created - Resource created successfully
202 Accepted - Request accepted for processing (async)
204 No Content - Request successful, no response body

CLIENT ERROR (4xx):
400 Bad Request - Invalid request syntax or data
401 Unauthorized - Authentication required
403 Forbidden - Request understood but refused
404 Not Found - Resource doesn't exist
405 Method Not Allowed - HTTP method not supported
409 Conflict - Request conflicts with current state
422 Unprocessable Entity - Request valid but semantically incorrect
429 Too Many Requests - Rate limit exceeded

SERVER ERROR (5xx):
500 Internal Server Error - Generic server error
501 Not Implemented - Server doesn't support functionality
502 Bad Gateway - Invalid response from upstream server
503 Service Unavailable - Server temporarily unavailable
504 Gateway Timeout - Upstream server timeout

=== URL STRUCTURE AND NAMING CONVENTIONS ===

RESOURCE NAMING:
✓ Use nouns, not verbs: /users (not /getUsers)
✓ Use plural forms: /users/123 (not /user/123)
✓ Use lowercase: /user-profiles (not /UserProfiles)
✓ Use hyphens for readability: /user-preferences
✓ Be consistent across all endpoints

HIERARCHY EXAMPLES:
/api/users                    - All users
/api/users/123               - Specific user
/api/users/123/orders        - Orders for specific user
/api/users/123/orders/456    - Specific order for specific user
/api/products               - All products
/api/products/789/reviews   - Reviews for specific product

QUERY PARAMETERS:
Filtering: /api/users?status=active&role=admin
Sorting: /api/products?sort=price&order=desc
Pagination: /api/users?page=2&limit=20
Search: /api/products?search=laptop&category=electronics

=== REQUEST AND RESPONSE FORMAT ===

CONTENT TYPES:
- JSON: application/json (most common)
- XML: application/xml
- Form data: application/x-www-form-urlencoded
- File upload: multipart/form-data

REQUEST EXAMPLE:
POST /api/users
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "name": "John Doe",
  "email": "john@example.com",
  "role": "user"
}

RESPONSE EXAMPLE:
HTTP/1.1 201 Created
Content-Type: application/json
Location: /api/users/123

{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "role": "user",
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}

=== AUTHENTICATION AND SECURITY ===

AUTHENTICATION METHODS:
1. API Keys:
   - Simple but less secure
   - Header: Authorization: Bearer <api-key>
   - Good for server-to-server communication

2. JWT (JSON Web Tokens):
   - Self-contained tokens with user info
   - Header: Authorization: Bearer <jwt-token>
   - Stateless, scalable solution

3. OAuth 2.0:
   - Industry standard for authorization
   - Good for third-party integrations
   - Multiple grant types available

4. Basic Authentication:
   - Username:password encoded in base64
   - Header: Authorization: Basic <encoded-credentials>
   - Only use over HTTPS

SECURITY BEST PRACTICES:
✓ Always use HTTPS in production
✓ Validate all input data
✓ Implement rate limiting
✓ Use proper authentication and authorization
✓ Don't expose sensitive data in URLs
✓ Implement CORS properly
✓ Use security headers (HSTS, CSP, etc.)
✓ Log security events
✓ Regular security audits

=== ERROR HANDLING ===

CONSISTENT ERROR FORMAT:
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      }
    ],
    "timestamp": "2024-01-15T10:30:00Z",
    "path": "/api/users"
  }
}

ERROR RESPONSE PATTERNS:
400 Bad Request:
{
  "error": {
    "code": "INVALID_REQUEST",
    "message": "Request body is required"
  }
}

404 Not Found:
{
  "error": {
    "code": "RESOURCE_NOT_FOUND",
    "message": "User with ID 123 not found"
  }
}

422 Unprocessable Entity:
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": [
      {"field": "email", "message": "Email already exists"}
    ]
  }
}

=== PAGINATION STRATEGIES ===

OFFSET-BASED PAGINATION:
Request: GET /api/users?page=2&limit=20
Response:
{
  "data": [...],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 150,
    "pages": 8,
    "has_next": true,
    "has_previous": true
  }
}

CURSOR-BASED PAGINATION:
Request: GET /api/users?cursor=eyJpZCI6MTIzfQ&limit=20
Response:
{
  "data": [...],
  "pagination": {
    "next_cursor": "eyJpZCI6MTQzfQ",
    "has_next": true,
    "limit": 20
  }
}

=== VERSIONING STRATEGIES ===

URL PATH VERSIONING:
/api/v1/users
/api/v2/users

HEADER VERSIONING:
Accept: application/vnd.myapi.v1+json
API-Version: 1.0

QUERY PARAMETER:
/api/users?version=1

SUBDOMAIN VERSIONING:
v1.api.example.com/users
v2.api.example.com/users

=== CACHING STRATEGIES ===

HTTP CACHE HEADERS:
Cache-Control: public, max-age=3600        # Cache for 1 hour
ETag: "abc123def456"                       # Entity tag for validation
Last-Modified: Wed, 15 Jan 2024 10:30:00 GMT
Expires: Thu, 16 Jan 2024 10:30:00 GMT

CACHING PATTERNS:
- Browser caching (client-side)
- CDN caching (edge locations)
- Reverse proxy caching (server-side)
- Database query caching
- Application-level caching (Redis, Memcached)

=== RATE LIMITING ===

RATE LIMIT HEADERS:
X-RateLimit-Limit: 1000          # Requests allowed per window
X-RateLimit-Remaining: 743       # Requests remaining
X-RateLimit-Reset: 1642248600    # When limit resets (Unix timestamp)

RATE LIMITING STRATEGIES:
- Fixed Window: 1000 requests per hour
- Sliding Window: More sophisticated, smooths out bursts
- Token Bucket: Allows bursts up to bucket capacity
- Leaky Bucket: Smooths out requests at constant rate

=== API DOCUMENTATION ===

ESSENTIAL DOCUMENTATION ELEMENTS:
✓ Base URL and authentication
✓ All endpoints with HTTP methods
✓ Request/response examples
✓ Parameter descriptions and types
✓ Status codes and error responses
✓ Rate limiting information
✓ SDKs and code examples

POPULAR DOCUMENTATION TOOLS:
- OpenAPI/Swagger: Standard specification
- Postman: API testing and documentation
- Insomnia: REST client with documentation
- API Blueprint: Markdown-based documentation
- GitBook: User-friendly documentation

=== TESTING REST APIs ===

TESTING LEVELS:
1. Unit Tests: Individual functions/methods
2. Integration Tests: API endpoints
3. Contract Tests: API specification compliance
4. End-to-End Tests: Complete user workflows
5. Load Tests: Performance under load

TESTING TOOLS:
- Postman: Manual and automated testing
- Insomnia: REST client and testing
- curl: Command-line testing
- pytest/unittest: Python testing frameworks
- JMeter: Load testing
- Newman: Command-line Postman runner

=== BEST PRACTICES SUMMARY ===

DESIGN PRINCIPLES:
✓ Keep it simple and intuitive
✓ Be consistent across all endpoints
✓ Use standard HTTP methods and status codes
✓ Provide meaningful error messages
✓ Version your API from the start

PERFORMANCE:
✓ Implement caching where appropriate
✓ Use pagination for large datasets
✓ Optimize database queries
✓ Implement rate limiting
✓ Use compression (gzip)

SECURITY:
✓ Always use HTTPS
✓ Implement proper authentication/authorization
✓ Validate all inputs
✓ Don't expose sensitive information
✓ Log security events

MAINTAINABILITY:
✓ Write comprehensive documentation
✓ Use consistent naming conventions
✓ Implement proper error handling
✓ Write tests for all endpoints
✓ Monitor API performance and usage

EVOLUTION:
✓ Version your API properly
✓ Maintain backward compatibility when possible
✓ Deprecate old versions gracefully
✓ Gather user feedback
✓ Monitor API analytics

=== COMMON ANTI-PATTERNS TO AVOID ===

❌ Using verbs in URLs: /api/getUserById/123
✅ Use nouns: /api/users/123

❌ Ignoring HTTP status codes: Always returning 200
✅ Use appropriate status codes: 404 for not found, 400 for bad request

❌ Exposing internal implementation: /api/database-table-name
✅ Use business domain names: /api/users

❌ Inconsistent naming: /api/user vs /api/users
✅ Be consistent: Always use plural forms

❌ Not handling errors properly: Generic error messages
✅ Provide specific, actionable error information

❌ Not implementing proper authentication
✅ Secure all endpoints appropriately

❌ Creating chatty APIs: Multiple requests for related data
✅ Design efficient endpoints that provide needed data

This guide provides a foundation for designing, implementing, and maintaining
REST APIs that are secure, performant, and