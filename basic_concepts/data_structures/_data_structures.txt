=== DATA STRUCTURES IN PYTHON ===

DEFINITION:
Data structures are specialized ways to organize, store, and access data efficiently.
They provide different trade-offs between memory usage, access time, insertion/deletion
speed, and ease of use. Choosing the right data structure is crucial for writing
efficient algorithms and solving problems effectively.

Think of data structures like different storage systems:
- List: Like a numbered filing cabinet (indexed access)
- Dictionary: Like a phone book (key-value lookup)  
- Stack: Like a stack of plates (last in, first out)
- Queue: Like a line at a store (first in, first out)

=== BUILT-IN DATA STRUCTURES ===

1. LIST (Dynamic Array):
   - Ordered, mutable collection of items
   - Allows duplicates, supports indexing
   - Time Complexity: Access O(1), Search O(n), Insert/Delete O(n)
   - Memory: Contiguous storage, can resize dynamically
   
   Use cases:
   - When you need ordered data with index access
   - Implementing stacks (append/pop from end)
   - Small to medium datasets where simplicity matters

2. TUPLE (Immutable Sequence):
   - Ordered, immutable collection of items
   - Allows duplicates, supports indexing
   - Time Complexity: Access O(1), Search O(n)
   - Memory: More memory efficient than lists
   
   Use cases:
   - Representing coordinates (x, y)
   - Dictionary keys (when you need multiple values)
   - Function return values (multiple returns)
   - Configuration data that shouldn't change

3. DICTIONARY (Hash Table):
   - Unordered collection of key-value pairs
   - Keys must be unique and immutable
   - Time Complexity: Access/Insert/Delete O(1) average, O(n) worst
   - Memory: Higher overhead due to hash table structure
   
   Use cases:
   - Fast lookups by key
   - Counting occurrences of items
   - Caching/memoization
   - Representing objects and JSON-like data

4. SET (Hash Set):
   - Unordered collection of unique items
   - No duplicates allowed
   - Time Complexity: Add/Remove/Contains O(1) average
   - Memory: Similar to dictionary overhead
   
   Use cases:
   - Removing duplicates from data
   - Mathematical set operations (union, intersection)
   - Membership testing for large datasets
   - Tracking visited items in algorithms

5. STRING (Immutable Sequence):
   - Immutable sequence of characters
   - Supports indexing and slicing
   - Time Complexity: Access O(1), Search O(n)
   - Memory: Immutable, so operations create new strings
   
   Use cases:
   - Text processing and manipulation
   - Pattern matching and regular expressions
   - File paths and URLs
   - User input validation

=== ADVANCED DATA STRUCTURES ===

1. COLLECTIONS MODULE:

   a) deque (Double-ended Queue):
      - Efficient insertions/deletions at both ends
      - Time Complexity: Append/Pop both ends O(1)
      - Use for: Queues, sliding window problems
      
   b) Counter:
      - Dictionary subclass for counting hashable objects
      - Provides convenient counting methods
      - Use for: Frequency counting, finding most common items
      
   c) defaultdict:
      - Dictionary with default values for missing keys
      - Reduces KeyError exceptions
      - Use for: Grouping data, building nested structures
      
   d) OrderedDict:
      - Dictionary that maintains insertion order
      - (Note: Regular dicts maintain order in Python 3.7+)
      - Use for: When order matters in older Python versions

2. HEAPQ (Priority Queue):
   - Binary heap implementation
   - Always maintains smallest element at index 0
   - Time Complexity: Insert/Delete O(log n)
   - Use for: Priority queues, finding k smallest/largest elements

=== ALGORITHM-SPECIFIC DATA STRUCTURES ===

1. STACK (LIFO - Last In, First Out):
   - Can be implemented using list
   - Operations: push (append), pop
   - Use for: Function calls, expression evaluation, backtracking
   
   Implementation:
   stack = []
   stack.append(item)  # push
   stack.pop()         # pop

2. QUEUE (FIFO - First In, First Out):
   - Best implemented using collections.deque
   - Operations: enqueue (append), dequeue (popleft)
   - Use for: BFS traversal, task scheduling, buffering
   
   Implementation:
   from collections import deque
   queue = deque()
   queue.append(item)    # enqueue
   queue.popleft()       # dequeue

3. LINKED LIST:
   - Not built-in, must be implemented manually
   - Dynamic size, efficient insertion/deletion
   - Use for: When frequent insertions/deletions in middle

4. TREE STRUCTURES:
   - Binary Tree, Binary Search Tree, AVL Tree
   - Not built-in, typically implemented as classes
   - Use for: Hierarchical data, fast searching, sorting

5. GRAPH:
   - Can be represented using dictionaries or adjacency matrices
   - Use for: Networks, relationships, pathfinding algorithms

=== CHOOSING THE RIGHT DATA STRUCTURE ===

PERFORMANCE CONSIDERATIONS:

Time Complexity Priority:
✓ Need O(1) access by key? → Dictionary
✓ Need O(1) access by index? → List
✓ Need O(1) insertion/deletion at ends? → deque
✓ Need to maintain sorted order? → heapq for min/max
✓ Need uniqueness checking? → Set

Space Complexity:
✓ Memory constrained? → Tuple over List
✓ Many small collections? → Avoid dictionaries/sets
✓ Large datasets? → Consider generators/iterators

Use Case Patterns:
✓ Counting items → Counter or defaultdict(int)
✓ Grouping data → defaultdict(list)
✓ Caching results → Dictionary
✓ Unique items only → Set
✓ Ordered processing → Queue (deque)
✓ Reverse processing → Stack (list)

=== COMMON PATTERNS AND IDIOMS ===

1. FREQUENCY COUNTING:
   from collections import Counter
   counter = Counter(items)
   most_common = counter.most_common(3)

2. GROUPING DATA:
   from collections import defaultdict
   groups = defaultdict(list)
   for item in data:
       groups[item.category].append(item)

3. MEMOIZATION:
   cache = {}
   def expensive_function(n):
       if n not in cache:
           cache[n] = compute_result(n)
       return cache[n]

4. SLIDING WINDOW:
   from collections import deque
   window = deque(maxlen=k)
   for item in stream:
       window.append(item)
       process_window(window)

5. UNION-FIND (Disjoint Set):
   parent = {}
   def find(x):
       if x not in parent:
           parent[x] = x
       if parent[x] != x:
           parent[x] = find(parent[x])
       return parent[x]

=== LEETCODE PROBLEM PATTERNS ===

ARRAY/LIST PROBLEMS:
- Two pointers technique
- Sliding window
- Kadane's algorithm (max subarray)
- Dutch national flag (3-way partitioning)

STRING PROBLEMS:
- Palindrome checking
- Anagram detection
- Longest substring problems
- Pattern matching

HASH TABLE PROBLEMS:
- Two sum variants
- Frequency analysis
- Subarray sum problems
- Duplicate detection

STACK PROBLEMS:
- Parentheses matching
- Next greater element
- Monotonic stack problems
- Expression evaluation

QUEUE/BFS PROBLEMS:
- Level-order traversal
- Shortest path in unweighted graphs
- Multi-source BFS

HEAP PROBLEMS:
- K largest/smallest elements
- Merge k sorted lists
- Meeting rooms optimization
- Median finding

=== SPACE-TIME TRADE-OFFS ===

COMMON TRADE-OFFS:

1. Hash Tables:
   - Trade memory for O(1) lookups
   - Good when lookup frequency is high

2. Preprocessing:
   - Trade initial computation time for faster queries
   - Example: Sorting array once for multiple binary searches

3. Caching:
   - Trade memory for avoiding repeated computations
   - Good for expensive operations with repeated inputs

4. Index Structures:
   - Trade memory for faster searches
   - Example: Building maps for O(1) access

=== BEST PRACTICES ===

1. UNDERSTAND YOUR DATA:
   - Size: Small (< 100), Medium (100-10K), Large (> 10K)
   - Access patterns: Sequential, random, frequent lookups
   - Modification frequency: Read-heavy, write-heavy, mixed

2. PROFILE FIRST:
   - Don't optimize prematurely
   - Measure actual performance bottlenecks
   - Consider both time and space complexity

3. PYTHON-SPECIFIC TIPS:
   - Lists are very optimized in CPython
   - Dictionary lookups are extremely fast
   - Set operations are usually faster than list operations for membership
   - deque is much faster than list for queue operations

4. READABILITY vs PERFORMANCE:
   - Start with readable code
   - Optimize only proven bottlenecks
   - Comment complex optimizations

5. MEMORY MANAGEMENT:
   - Be aware of reference cycles
   - Use generators for large datasets
   - Consider __slots__ for memory-critical classes

=== CONCLUSION ===

Choosing the right data structure is fundamental to writing efficient code. The key
principles are:

1. Understand your access patterns and performance requirements
2. Know the time/space complexity of operations
3. Start simple and optimize when needed
4. Consider Python-specific optimizations and idioms

For coding interviews and competitive programming:
- Master the built-in structures first
- Understand when to use each structure
- Practice implementing common algorithms with different structures
- Learn to recognize patterns that suggest specific data structures

Remember: The best data structure is the one that makes your code correct,
readable, and performant enough for your specific use